CameraStates = {
    Red = {
        position = {
            x = -16.5583878,
            y = -2.5,
            z = -14
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Orange = {
        position = {
            x = -16.5583878,
            y = -2.5,
            z = 0
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Yellow = {
        position = {
            x = -16.5583878,
            y = -2.5,
            z = 11
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Blue = {
        position = {
            x = 14.5,
            y = -2.5,
            z = 0
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Purple = {
        position = {
            x = 14.5,
            y = -2.5,
            z = -14
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Teal = {
        position = {
            x = 14.5,
            y = -2.5,
            z = 11
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Green = {
        position = {
            x = -16.5583878,
            y = -2.5,
            z = 23
        },
        pitch = 90,
        yaw = 0,
        distance = 20
    },
    Multi = {
        position = {
            x = -1,
            y = -2.5,
            z = 0
        },
        pitch = 90,
        yaw = 0,
        distance = 15
    },
}

Colors = {'Red', 'Orange', 'Yellow', 'Green', 'Teal', 'Blue', 'Purple'}

PlayerBoards = {
    Red = {
        '4b3a9e', 'df0dd7', 'dd9a11', '65e693', '0e0d58', '0e6cb8',
        '2186ff', 'bcd42b', '8cdd7c', 'b88daf', 'e8fe84', 'e0e383', '4f95ef'
    },
    Orange = {
        'c1f6ed', '218833', 'b6a3bb', '23b599', '3340bf', '4fed4b',
        '173f6b', '1ed112', '465b50', 'fd8fa4', 'fb44d6', 'e8ed28', '4af7c0'
    },
    Yellow = {
        '7db764', '462f81', '3dce1c', '96e4dd', 'f5949f', 'a5c289',
        '73947c', '8d8f04', '68129e', '217d9b', '53edce', 'b0f3c1', 'c2ae00'
    },
    Blue = {
        'b5ad97', '00d6f0', '4c499b', '4c8fac', '428bf0', '727bf9',
        '9c866a', '737b97', 'e4f4a6', '5b61f4', 'a9957e', '716f2c', '85f58b'
    },
    Purple = {
        'dd2ded', 'a8a985', '9c4b0c', '64b697', '33a93a', '667627',
        'a01003', '88a32c', '2c9482', '4d4260', '34871c', 'fea48b', 'd382e6'
    },
    Green = {
        '8b8731', 'c79482', 'e4427a', '243526', '524465', '54b0f0', 
        '8be4cc', '7bbda6', 'fefad9', 'e991c5', '0d2e0f', '640746', 'd7fe96'
    },
    Teal = {
        'd3cbf1', '0ff5c6', 'd10c8e', '4bec1d', '4a4a95', 'e24447', 
        'cf439d', '130dd5', '704b4f', '0443ff', '5e5b05', 'f2289f', '3b4252'
    }
}

PlayerCubes = {
  Red = {'c3fad2', 'e3d8bd', '866851'},
  Orange = {'5e6458', 'cb0bf7', '583ef4'},
  Yellow = {'c0f66c','b2271a','19bd7d'},
  Blue = {'8a2f0c', '7e81ce', '70c25d'},
  Purple = {'204671', '9c1b52', 'e4c4f9'},
  Green = {'60da38', 'a7be6e', 'f1e307'},
  Teal = {'46faa7', '671fa8', '0c1379'}
}

DeploySections = {
    Red = {
        '1e91c0', '0a9a51', '7132c1', 'ce2d11', 'a60744', '9172b3',
        '052e97', '0ff00e', 'b9ad35', 'd12f6a', 'b668f0', 'd49bb4', 'a6e439'
    },
    Orange = {
        '4f84b3', '14f65b', '6ee3a4', 'a96c73', '40e87d', '0db2ae', 
        'b68952', 'c8bf64', 'c1e65c', '2160f9', '741b75', 'f53898', '28c06d'
    },
    Yellow = {
        '3606da', 'f5bb44', '6afbe6', '74912e', 'a1c3be', '29a023', 
        '1e1664', '1e17d8', '3f603e', 'bd8b7d', '63c219', 'db0d1b', '610a68'
    },
    Blue = {
        'c42ac6', '9271b3', 'c1cca0', 'ae787c', '42aa9b', '447f81',
        '469ac7', '60ead7', '343588', '7de7bf', 'cd5412', '175990', 'e0ac22'
    },
    Purple = {
        '671ba5', '69e7bd', '26c451', '9ddcc1', '7e1222', '91e5e6',
        'c433fe', '17894d', '93d12e', 'e37bb3', '4bf917', '4af6a4', 'c865bb'
    },
    Green = {
        '0c51dc', 'f1c60d', 'c3a004', 'e6f5cb', 'd82032', 'c4e8dd', 
        'c8c991', '644a2f', '8c7e8e', '9fd723', 'ead3c7', '3d1adc', 'f8d748'
    },
    Teal = {
        '0a0cd8', '0c7fa9', '78e6a6', 'c65120', '3bfe34', 'a59662', 
        'f46e79', '2ed802', 'b38166', '647645', '106c41', '5e27c9', '904f6b'
    }
}

DiscardZones = {
    Red = 'c08c97',
    Orange = '97166b',
    Yellow = '2bb649',
    Blue = '7da947',
    Purple = '82f36f',
    Green = 'd159d1',
    Teal = '7cd0b3'
}

-- Actual decks
Sectors = {'0124ec', 'e5c908', '0ed9c0'}

LastDropped = {
    Red = {},
    Orange = {},
    Yellow = {},
    Blue = {},
    Purple = {},
    Green = {},
    Teal = {}
}

heightIncrement = -0.01
heightFirst = 1.17
rightIncrements = {0, 1.42, 2.82, 4.21, 5.95, 7.35, 8.74, 10.14, 11.87, 13.27, 14.66, 16.07, 18.19}

TallDeployments = {'c08c9b', '5b4153', 'e2a4c6', 'c572af', 'b0e8f8', '1394ec', '07b1d1', '3e70aa', 'ed5be4'}
TallerDeployments = {'11d1fc', 'f0d126', 'ce3512', 'd1d0ea', '66ac96', '1bc92b', '8fadea', '3a81fe', '65d15a', '233671', '26f271', '1aa4c6', 'eb14a4', 'd0a0ae', '3a3ad8', 'c17f91', 'e540c8', '5aa245', '5aa245', '52d0f8', 'e27613',
-- 6/7 player start cards
'65d15a', 'd1d0ea', '11d1fc', 'eb14a4', '3a81fe', '66ac96', '233671', '1aa4c6', 
'8fadea', '1bc92b', 'ce3512', 'd0a0ae', 'f0d126', '26f271'
 }
Tall2Deployments = {'36ddd9', '82370d', '71c3e0', 'a8cb0f', '4cde5d', 'f1df7e', '8669dd', 'd02079', '5c9d9b', '80ce3d', 'dbb1b2', '734b3c'}

CardPosition = {
    Red = { up = -10.9, right = -24.74, orig = -11.03 },
    Orange = { up = 1.1, right = -24.74, orig = 0.97 },
    Yellow = { up = 13.12, right = -24.74, orig = 12.97 },
    Blue = { up = 1.1, right = 8.26, orig = 0.97 },
    Purple = { up = -10.9, right = 8.26, orig = -11.03 },
    Green = { up = 25.12, right = -24.74, orig = 24.97 },
    Teal = { up = 13.12, right = 8.26, orig = 12.97 }
}

-- Starter Card Positions
Starters = {
    Red = {-22.42, 4, -16.78},
    Orange = {-22.42, 4, -5.22},
    Yellow = {-22.42, 4, 6.80},
    Green = {-22.42, 4, 18.80},
    Purple = {10.26, 4, -16.41},
    Blue = {10.26, 4, -5.22},
    Teal = {10.26, 4, 6.80}
}
selectedStartingPlayer = 'Red'
    
ShyPlutoDiceY = 1.25
ShyPlutoDiceX = {-1.68, -0.89, -0.10, 0.71, 1.48, 2.29}
ShyPlutoDiceZ = 19.61
ShyPlutoDiceZone = '3f8721'
ShyPlutoButton = '3c5547'

resupplyInProgress = false

startPlayerCard = nil
gameLoaded = false
SectorDecks = nil
Expansions = nil
Utility = nil

function onLoad()
    UI.hide('FirstPlayerPanel')
    Utility = getObjectFromGUID('431e88')
    startPlayerCard = getObjectFromGUID('ede71b')
    SectorDecks = getObjectFromGUID('c1471e')
    Expansions = getObjectFromGUID('4510f9')
    math.randomseed(os.time())
    -- Set items uninteractable
    for key, value in ipairs({
            -- Player Boards
            'e58bea', '93553d', '2eaddb', 'fc21ad', 'a917cc', '0b40bb', '707903', 
            -- Table
            '12c65e', 'f938a2', 'afc863', '9f95fd', 'c8edca', '35b95f', '393bf7', '5af8f2', '4ee1f2',
            -- Shy Pluto Card
            'aa6cc3',
            -- Floor and stools
            'b1cad7', '5f9ba8', '28c93d',
            -- Help table
            '71a899'
        }) do
        if (getObjectFromGUID(value) != nil) then
            getObjectFromGUID(value).interactable = false
        end
    end
    
    for c=1,7 do
        for k=1,13 do
            local playerBoardSector = getObjectFromGUID(PlayerBoards[Colors[c]][k]);
            if (playerBoardSector != nil) then
                playerBoardSector.createButton({
                    click_function = Colors[c] .. "Deploy" .. k, 
                    function_owner = Global,
                    label          = "Deploy",
                    position       = {0.05,-0.15,1.25},
                    rotation       = {0,180,0},
                    width          = 300,
                    height         = 200,
                    font_size      = 70,
                    color          = {0, 0, 0},
                    font_color     = {1, 1, 1},
                })
            end
        end
    end
    
    if (startPlayerCard.hasTag('started')) then
        UI.hide('StartPanel')
    end
    
    gameLoaded = true
end

function onObjectDrop(colorName, obj)
    if (obj.type == 'Card') then
        LastDropped[colorName] = obj.guid
    end
end

function onObjectEnterScriptingZone(zone, card)
    -- Only act if dropped in the auto deploy script zone
    if (zone.guid != '73274b') then return end
    -- Find the color that dropped this card
    for key, playerColor in ipairs(getSeatedPlayers()) do
        -- Do nothing if this is a non player
        if (Utility.call('isPlayerColor', playerColor) == false) then return end
        -- Get the color of the player who dropped the card
        if (LastDropped[playerColor] == card.guid) then
            for k, rotationValue in ipairs(card.getRotationValues()) do
                -- Sector number
                local sectorNumber = rotationValue.value
                if (string.find(sectorNumber, '+')) then
                    print('A ' .. sectorNumber .. ' card must be manually deployed.')
                    return
                end
                
                sectorNumber = tonumber(sectorNumber)
                
                local sectorPileObject = getObjectFromGUID(PlayerBoards[playerColor][sectorNumber])
                local deployGuid = DeploySections[playerColor][sectorNumber]
                
                -- We want to deploy a sector 13 card immediately
                if (sectorNumber == 13) then
                    local right = CardPosition[playerColor].right + rightIncrements[sectorNumber]
                    card.setPositionSmooth({right, 2, CardPosition[playerColor].orig}, false, false)
                    card.setRotationSmooth({0,180,0})
                    Wait.time(function() deploy(sectorPileObject, sectorNumber, deployGuid, playerColor) end, 1.3)
                    return
                end
                
                deploy(sectorPileObject, sectorNumber, deployGuid, playerColor, false)
                
                local right = CardPosition[playerColor].right + rightIncrements[sectorNumber]
                card.setPositionSmooth({right, 2, CardPosition[playerColor].orig}, false, false)
                card.setRotationSmooth({0,180,0})
                
            end
        end
    end
end

function start()
    local hasColors = Utility.call('hasPlayerSelectedColors')
    if (not hasColors) then
        print('At least one player must select a color before starting the game.')
        return
    end
    UI.hide('StartPanel')
    
    Expansions.call('addSelectedExpansions')
    
    -- Give the starter card "Started" tag to know on load if this is loading a saved game
    startPlayerCard.addTag('started')
    
    -- If a 6 or 7 player game, give each player a sector 7 and 8 McCaffery Monitor-Relay Class Craft
    if (#Player.getPlayers() > 5) then
        for _, player in ipairs(Player.getPlayers()) do
            local card7 = Utility.call('getTopCard', getObjectFromGUID('6b7b2c'))
            local card8 = Utility.call('getTopCard', getObjectFromGUID('dd25cd'))
            deployCard(card7, 6, 0, getDeployHeight(card7.guid), player.color, true, false)
            deployCard(card8, 7, 0, getDeployHeight(card8.guid), player.color, true, false)
        end
    end
    
    -- Shuffle the sector decks
    SectorDecks.call("shuffleSectorDecks")
    print('Resupplying marketplace.')
    Turns.enable = true
    
    -- Wait.time(startShuffleDeal, 0.1)
    -- Deal starting cards (and pilot tokens if playing Shy Pluto) for active players
    for key, value in ipairs(Utility.call('getTurnOrderFromStartingPlayer'), Turns.turn_color) do
        dealCard(Starters[value], 1, 1)
        
        if (startPlayerCard.hasTag('haveLightSpeed')) then
            -- Give out more cards
            dealCard(Starters[value], 1, 2)
            dealCard(Starters[value], 1, 3)
            dealCard(Starters[value], 1, 4)
            dealCard(Starters[value], 2, 5)
            dealCard(Starters[value], 2, 6)
            
            -- Update to 15 currency and 1 income
            local moneyCube = getObjectFromGUID(PlayerCubes[value][1])
            local moneyPos = moneyCube.getPosition()
            moneyCube.setPositionSmooth({moneyPos[1]+4.13, moneyPos[2], moneyPos[3]})
            
            local incomeCube = getObjectFromGUID(PlayerCubes[value][2])
            local incomePos = incomeCube.getPosition()
            incomeCube.setPositionSmooth({incomePos[1]+0.4, incomePos[2], incomePos[3]})
            
        end

        -- Give out pilot tokens
        if (startPlayerCard.hasTag('haveShyPluto') or startPlayerCard.hasTag('haveTerraProxima')) then
            local PilotBag = Expansions.call('getPilotBag', value)
            if (PilotBag != nil) then
                PilotBag.takeObject({
                    position = {x=Starters[value][1]+10, y=Starters[value][2], z=Starters[value][3]},
                    rotation = {0,180,0},
                    smooth = true
                })
            end
        end
    end
    print('Giving out starter cards.')
    
    gameStarted = true
    
    if (startPlayerCard.hasTag('haveLightSpeed')) then
        UI.setAttributes('FirstPlayerPanelText', {
        text = 'Set which color is the starting player. This is the player with the highest remaining currency. A dice roll breaks ties.'
    })
    end
    
    -- Show set starting player
    UI.show('FirstPlayerPanel')
    hideStarterOptionsForNonPlayers()
end

function hideStarterOptionsForNonPlayers()
    UI.hide('StarterOptionRed')
    UI.hide('StarterOptionOrange')
    UI.hide('StarterOptionYellow')
    UI.hide('StarterOptionGreen')
    UI.hide('StarterOptionTeal')
    UI.hide('StarterOptionBlue')
    UI.hide('StarterOptionPurple')
    
    for key,value in ipairs(getSeatedPlayers()) do
        if (Utility.call('isPlayerColor', value)) then
            UI.show('StarterOption' .. value)
        end
    end
end

function dealCard(positionObj, sector, iteration)
    iteration = iteration - 1
    local pos = {x=positionObj[1]+(1.5 * iteration), y=positionObj[2], z=positionObj[3]}
    getObjectFromGUID(Sectors[sector]).takeObject({
        position = pos,
        rotation = {0,180,0}
    })
end

function CameraViewClicked(player, value, id)
    player.lookAt(CameraStates[id])
end


-- Swap all cards in a sector with those from another sector
function swapSectorCards()
    -- The sectors that the two checkers are on will determine which to swap
    Checker1 = getObjectFromGUID('3630f7')
    Checker2 = getObjectFromGUID('a12ea2')
    local locOne = getSectorLocation(Checker1)
    local locTwo = getSectorLocation(Checker2)
    if (locTwo[2] == 0 or locOne[2] == 0) then
        print("Both checkers must be on a sector to swap sectors.")
        return
    end
    if (locOne[1] != locTwo[1]) then
        print("You can't swap sectors from different player boards.")
        return
    end
    print('Swapping ', locOne[1], ' sectors ', locOne[2], ' and ', locTwo[2], '.')
    
    -- Return the checkers to the original location
    Checker1.setPositionSmooth({-0.46, 1.12, -14.32}, false, false)
    Checker2.setPositionSmooth({0.89, 1.12, -14.32}, false, false)
    
    local Sector1 = getObjectFromGUID(PlayerBoards[locOne[1]][locOne[2]])
    local Sector2 = getObjectFromGUID(PlayerBoards[locOne[1]][locTwo[2]])
    local Deploy1 = getObjectFromGUID(DeploySections[locOne[1]][locOne[2]])
    local Deploy2 = getObjectFromGUID(DeploySections[locOne[1]][locTwo[2]])
    local Position1 = Sector1.getPosition()
    local Position2 = Sector2.getPosition()
    local DeployPosition1 = Deploy1.getPosition()
    local DeployPosition2 = Deploy2.getPosition()
    moveHorizontal(Sector1, Position2[1])
    moveHorizontal(Sector2, Position1[1])
    moveHorizontal(Deploy1, Position2[1])
    moveHorizontal(Deploy2, Position1[1])
end

function moveHorizontal(zone, xPosition)
    local objects = zone.getObjects()
    for _, object in ipairs(objects) do
        local type = object.type
        if object.type == "Card" or object.type == "Deck" then
            local position = object.getPosition()
            object.setPositionSmooth({xPosition, position[2], position[3]})
        end
    end
end

function getSectorLocation(obj)
    local position = obj.getPosition()
    local right = Utility.call('round', {number = position[1], places = 1})
    local rightIndex = 0
    -- There are 24 (26 with proxima) x-positions the sectors can be in
    local totalSectorPositions = 12
    if (startPlayerCard.hasTag('haveTerraProxima')) then totalSectorPositions = 13 end
    for k=1,(totalSectorPositions * 2) do
        if (k < (totalSectorPositions + 1)) then
            if (tostring(right) == tostring(Utility.call('round', { number = CardPosition.Green.right + rightIncrements[k], places = 1}))) then
                rightIndex = k
            end
        else 
            if (tostring(right) == tostring(Utility.call('round',  {number = CardPosition.Purple.right + rightIncrements[k-totalSectorPositions], places = 1}))) then
                rightIndex = k
            end
        end
    end   
    
    -- Determine the yPosition
    local upIndex = (Utility.call('round', { number = position[3], places = 0}) + 23) / 12
    
    local color = ''
    if (rightIndex < (totalSectorPositions + 1)) then
        if (upIndex == 1) then color = 'Red' end
        if (upIndex == 2) then color = 'Orange' end
        if (upIndex == 3) then color = 'Yellow' end
        if (upIndex == 4) then color = 'Green' end
    end
    if (rightIndex > totalSectorPositions) then
        if (upIndex == 1) then color = 'Purple' end
        if (upIndex == 2) then color = 'Blue' end
        if (upIndex == 3) then color = 'Teal' end
    end
    
    if (rightIndex > totalSectorPositions) then rightIndex = rightIndex - totalSectorPositions end
    return {color, rightIndex}
end

-- Toggles expansions on/off
function toggleOption(player, value, id, key, title)
    local label = ''
    local color = 'rgb(0.5,0.5,0.5)'
    
    if startPlayerCard.hasTag(key) then
        startPlayerCard.removeTag(key)
        label = title .. ": Off"
    else
        startPlayerCard.addTag(key)
        label = title .. ": On"
        color = 'rgb(0.2,0.52,1)'
    end
    UI.setAttributes(id, {
        text = label,
        textColor = 'white',
        color = color
    })
end

function biodomeToggle(player, value, id)
    toggleOption(player, value, id, 'haveBiodome', 'Biodome')
end

function dreadnaughtToggle(player, value, id)
    toggleOption(player, value, id, 'haveDreadnaught', 'Dreadnaught')
end

function shyPlutoToggle(player, value, id)
    toggleOption(player, value, id, 'haveShyPluto', 'Shy Pluto')
end

function terraProximaToggle(player, value, id)
    toggleOption(player, value, id, 'haveTerraProxima', 'Terra Proxima')
end

function lightSpeedToggle(player, value, id)
    toggleOption(player, value, id, 'haveLightSpeed', 'Light-speed Variant')
end

function startingOptionSelected(player, option, id)
    selectedStartingPlayer = Colors[option + 1]
end

function SetStartingPlayer()
    -- Player order table
    local turnOrder = Utility.call('getTurnOrderFromStartingPlayer', selectedStartingPlayer)
    
    for index, value in ipairs(turnOrder) do
        local moneyCube = getObjectFromGUID(PlayerCubes[value][1])
        local moneyPos = moneyCube.getPosition()
        local incomeCube = getObjectFromGUID(PlayerCubes[value][2])
        local incomePos = incomeCube.getPosition()
            
        if (index == 2) then
            moneyCube.setPositionSmooth({moneyPos[1]+0.4, moneyPos[2], moneyPos[3]})
        end
        if (index == 3) then
            moneyCube.setPositionSmooth({moneyPos[1]+0.8, moneyPos[2], moneyPos[3]})
        end
        if (index == 4 or index == 5) then
            if (startPlayerCard.hasTag('haveTerraProxima')) then
                moneyCube.setPositionSmooth({moneyPos[1]+1.2, moneyPos[2], moneyPos[3]})
            else
                incomeCube.setPositionSmooth({incomePos[1]+0.4, incomePos[2], incomePos[3]})
            end
        end
        if (index == 6 or index == 7) then
            if (startPlayerCard.hasTag('haveTerraProxima')) then
                moneyCube.setPositionSmooth({moneyPos[1]+1.6, moneyPos[2], moneyPos[3]})
            else
                incomeCube.setPositionSmooth({incomePos[1]+0.4, incomePos[2], incomePos[3]})
            end
        end
    end
    
    returnUnpurchasedCards()
    
    -- Move starting player card to starting player
    startPlayerCard.setPositionSmooth({
        Starters[selectedStartingPlayer][1], 
        Starters[selectedStartingPlayer][2], 
        Starters[selectedStartingPlayer][3]
    })
    
    Turns.turn_color = turnOrder[1]
    UI.hide('FirstPlayerPanel')
end

function returnUnpurchasedCards()
    local sector1 = getObjectFromGUID(Sectors[1])
    local sector2 = getObjectFromGUID(Sectors[2])
    
    for key, color in ipairs(getSeatedPlayers()) do
        if (Utility.call('isPlayerColor', color)) then
            local zone = getObjectFromGUID(DiscardZones[color])
            local objects = zone.getObjects()
            for index, object in ipairs(objects) do
                local type = object.type
                if (string.find(type, 'Deck') or string.find(type, 'Card')) then
                    if (object.hasTag('sector 1')) then
                        sector1.putObject(object)
                    end
                    if (object.hasTag('sector 2')) then
                        sector2.putObject(object)
                    end
                end
            end
        end
    end
end

-- Deploy or undeploy a card from clicking the deploy button
function deployRouting(sector, xpos, deployGuid, color, altClick)
    if (altClick == false) then deploy(sector, xpos, deployGuid, color)
    else undeploy(sector, xpos, deployGuid, color)
    end
end

-- Takes the card on the station, flips it upside down, and tucks it under the board
-- and under the topmost deployed card of that sector
function deploy(sector, sectorNumber, deployGuid, color)
    sectorNumber = sectorNumber - 1
    local cards = {}
    
    -- Get the currently deployed cards
    local deployedZone = getObjectFromGUID(deployGuid)
    for index, card in ipairs(deployedZone.getObjects()) do
        local type = card.tag
        if (string.find(type, 'Deck') or string.find(type, 'Card')) then
            table.insert(cards, card)
        end
    end
    
    -- Reposition all deployed cards, which will fix any misalignment if a card was
    -- manually removed
    local deployedCount = 0
    upSum = 0
    flip = true
    if (sectorNumber == 12) then
        upSum = 0.22
        flip = false
    end
    -- Loop through deployed cards in y-position order and deploy them
    for index, card in spairs(cards, function(t,a,b) return t[b].getPosition()[3] > t[a].getPosition()[3] end) do
        upSum = upSum + getDeployHeight(card.guid)
        deployCard(card, sectorNumber, index-1, upSum, color, flip, false)
        deployedCount = deployedCount + 1
    end
    -- Deploy the card in the station
    local foundCard = Utility.call('find_pile', sector)
    
    if (foundCard != nil) then
        -- Don't deploy the upgrade boards even though they are technically cards
        upSum = upSum + getDeployHeight(foundCard.guid)
        deployCard(foundCard, sectorNumber, deployedCount, upSum, color, flip, true)
    end
end

function getDeployHeight(guid)
    if Utility.call('has_value', {table = TallDeployments, value = guid}) then return 0.71 end
    if Utility.call('has_value', {table = TallerDeployments, value = guid}) then return 1.17 end
    if Utility.call('has_value', {table = Tall2Deployments, value = guid}) then return 0.89 end
    return 0.55
end

-- Move the topmost deployed card back to the station
function undeploy(sector, xpos, deployGuid, color)
    local topPosition = nil
    local topCard = nil
    
    local deployed = getObjectFromGUID(deployGuid)
    for index, card in ipairs(deployed.getObjects()) do
        local type = card.tag
        if (string.find(type, 'Deck') or string.find(type, 'Card')) then
            if (topPosition == nil) then 
                topCard = card
                topPosition = topCard.getPosition()[3]
            end
            if (card.getPosition()[3] > topCard.getPosition()[3]) then
                topCard = card
            end
        end
    end
    
    if (topCard == nil) then return end
    topCard.setLock(false)
    local topCardPosition = topCard.getPosition()
    topCard.setPositionSmooth({topCardPosition[1], 1.23, CardPosition[color].orig}, false, true)
    topCard.setRotationSmooth({0,180,0}, false, true)
end

-- Move the station card to the topmost deployed spot
function deployCard(card, xpos, ypos, upSum, color, flip, shouldMoveCharges)   
    local charges
    if (shouldMoveCharges == true) then 
        charges = getCharges(card)
    end
    
    if (flip == true) then
        card.setRotationSmooth({0,360,0}, false, true)
    end
    card.setLock(true)
    
    local right = CardPosition[color].right + rightIncrements[xpos+1]
    local up = CardPosition[color].up + upSum
    local height = heightFirst + (heightIncrement*(ypos))
    card.setPositionSmooth({right, height, up}, false, true)
    
    if (shouldMoveCharges == true) then
        moveCharges(card, charges)
    end
end

function moveCharges(card, charges)
    Wait.time(function() 
        local snapPositions = getSnapPoints(card, true)
        for key, charge in ipairs(charges) do
            if (snapPositions[key] != nil) then
                charge.setPositionSmooth(snapPositions[key], false, true)
            else
                charge.unregisterCollisions()
                charge.highlightOn(Color(1, 0, 0))
                local chargePosition = charge.getPosition()
                charge.setPositionSmooth({chargePosition[1], 4,chargePosition[3]})
                print('Removing extra charge')
                Wait.time(function() Utility.call('checkDestruct', charge) end, 1.5)
            end
        end
    end, 0.35)
end

-- Detect charges on the station card
-- If there are charge slots on the deployed side, move existing charges there
-- Delete extra charges
function getCharges(object)
    local hitList = Physics.cast({
        origin       = object.getPosition(),
        direction    = {0,1,0},
        type         = 3,
        size         = { 1.3, 1, 3.10},
        max_distance = 1
    })
    
    local chargeObjects = {};

    for key, value in ipairs(hitList) do
        if (value.hit_object.type == 'Block') then
            table.insert(chargeObjects, value.hit_object)
        end        
    end

    return chargeObjects;
end

function getSnapPoints(object, isDeployed)
    local snapPoints = {};
    for key, value in ipairs(object.getSnapPoints()) do
        if (isDeployed and value.position[3] > 1) then 
            table.insert(snapPoints, object.positionToWorld(value.position))
        end
        if (not isDeployed and value.position[3] < 1) then
            table.insert(snapPoints, object.positionToWorld(value.position))
        end
    end
    return snapPoints
end

-- Fill empty shy pluto spots by moving dice to the left, and then draw
-- new dice to fill remaining spots
function deployDice()
    if (resupplyInProgress == true) then return end

    resupplyInProgress = true
    Wait.time(function() resupplyInProgress = false end, 2)
    local dice = {}
    
    local deployed = getObjectFromGUID(ShyPlutoDiceZone)
    if (deployed) then
        for key, die in ipairs(deployed.getObjects()) do
            local type = die.tag
            if (string.find(type, 'Dice')) then
                table.insert(dice, die)
            end
        end
    end
    
    lastEmptyPosition = 1;    
    for index, die in spairs(dice, function(t,a,b) return t[b].getPosition()[1] > t[a].getPosition()[1] end) do
        die.setPositionSmooth({ShyPlutoDiceX[lastEmptyPosition], ShyPlutoDiceY, ShyPlutoDiceZ})
        lastEmptyPosition = lastEmptyPosition + 1
    end
    
    local miningDiceBag = Expansions.call('getMiningDiceBag')
    miningDiceBag.shuffle()

    if (lastEmptyPosition < 7) then
        for k=lastEmptyPosition, 6 do
            miningDiceBag.takeObject({
                position = {x=ShyPlutoDiceX[k], y=ShyPlutoDiceY, z=ShyPlutoDiceZ},
                rotation = {x=270, y=180, z=0},
                smooth = true
            })
        end
    end
end

-- Create all deploy functions since Tabletop Simulator doesn't support
-- passing parameters into buttons
for c=1,7 do
    for k=1,13 do
        -- Create a new global function
        _G[Colors[c] .. 'Deploy' .. k] = function(obj, color, alt_click) 
            deployRouting(obj, k, DeploySections[Colors[c]][k], Colors[c], alt_click)
        end
    end
end

-- The game always starts on the Red player's turn. If there is no Red player,
-- the turn automatically switches to the next player. If a Red player exists,
-- onPlayerTurnEnd will not trigger.
function onPlayerTurnEnd(color)
    if (gameLoaded == false) then return end
    if (startPlayerCard.hasTag('started') and Turns.enable == true) then
        SectorDecks.call("resupplySectors")
    end
    -- Player turn end can be called before objects are loaded
    if (startPlayerCard.hasTag('haveShyPluto') or startPlayerCard.hasTag('haveTerraProxima')) then
        local miningDiceBag = Expansions.call('getMiningDiceBag')
        if (miningDiceBag != nil) then
            deployDice()
        end
    end
end

-- Sorts a table
function spairs(t, order)
    -- collect the keys
    local keys = {}
    for k in pairs(t) do keys[#keys+1] = k end

    -- if order function given, sort by it by passing the table and keys a, b,
    -- otherwise just sort the keys 
    if order then
        table.sort(keys, function(a,b) return order(t, a, b) end)
    else
        table.sort(keys)
    end

    -- return the iterator function
    local i = 0
    return function()
        i = i + 1
        if keys[i] then
            return keys[i], t[keys[i]]
        end
    end
end

